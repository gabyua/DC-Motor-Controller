<?xml version="1.0" encoding="UTF-8"?>

<synergyModuleDescription>

    <config id="config.framework.sf_el_ux" path="ssp_cfg/framework/sf_el_ux_cfg.h" version="0">
        <property default="config.framework.sf_el_ux.VBUSENpin_logic.active_high" display="VBUSEN pin Signal Logic" id="config.framework.sf_el_ux.VBUSENpin_logic" description="Select the VBUSEN pin signal logic.">
            <option display="Active Low"  id="config.framework.sf_el_ux.VBUSENpin_logic.active_low"  value="(1)"/>
            <option display="Active High" id="config.framework.sf_el_ux.VBUSENpin_logic.active_high" value="(0)"/>
        </property>
        <property default="" display="High Speed Interrupt Priority" id="config.framework.sf_el_ux.hs_irq_ipl" description="Select the interrupt priority for high speed USB.">
            <select enum="enum.mcu.nvic.priorities.optional"/>
        </property>
        <property default="" display="Full Speed Interrupt Priority" id="config.framework.sf_el_ux.fs_irq_ipl" description="Select the interrupt priority for full speed USB">
            <select enum="enum.mcu.nvic.priorities.optional"/>
        </property>
        <content>
            #if ${config.framework.sf_el_ux.VBUSENpin_logic}
            #if !defined(UX_HOST_VBUS_ENABLE_LOW)
            #define UX_HOST_VBUS_ENABLE_LOW
            #endif
            #if ( defined(BSP_BOARD_S7G2_SK) || defined(BSP_BOARD_S5D9_PK) || defined(BSP_BOARD_S5D9_ASK) )
            #ifndef UX_HOST_VBUS_ENABLE_LOW
            #define UX_HOST_VBUS_ENABLE_LOW
            #endif
            #endif
            #endif

            #if (${config.framework.sf_el_ux.hs_irq_ipl} != BSP_IRQ_DISABLED)
            #define UX_HCD_SYNERY_USE_USBHS
            #define UX_DCD_SYNERY_USE_USBHS
            #endif

            #define SF_EL_UX_HCD_CFG_HS_IRQ_IPL      ${config.framework.sf_el_ux.hs_irq_ipl}
            #define SF_EL_UX_DCD_CFG_HS_IRQ_IPL      ${config.framework.sf_el_ux.hs_irq_ipl}
            #define SF_EL_UX_HCD_CFG_FS_IRQ_IPL      ${config.framework.sf_el_ux.fs_irq_ipl}
            #define SF_EL_UX_DCD_CFG_FS_IRQ_IPL      ${config.framework.sf_el_ux.fs_irq_ipl}
            
        </content>
    </config>
    <module config="config.framework.sf_el_ux" display="Framework|USB|[DEPRECATED] ${module.framework.sf_el_ux.name} USBX Port HS and FS on sf_el_ux" id="module.framework.sf_el_ux" version="1" url="http://knowledgebase.renesas.com/English_Content/Renesas_Synergy%E2%84%A2_Platform/Renesas_Synergy_Knowledge_Base/sf_el_ux_Module_Guide_Resources">
        <constraint display="Module instances must have unique names">
            "${interface.framework.sf_el_ux.${module.framework.sf_el_ux.name}}" === "1"
        </constraint>
        <constraint display="Requires USBX Interrupt (USBFS USBI or USBHS USBIR) enabled">
            ("${board.icu.usbfs.int}" != "board.icu.common.irq.disabled") || ("${board.icu.usbhs.usb_int_resume}" != "board.icu.common.irq.disabled")
        </constraint>
        <constraint display="This module has been deprecated. Please consider moving to the updated USBX Port on sf_el_ux implementation found under X-Ware/USBX/Host/Synergy Port/ or /Device/Synergy Port/.">
            "${module.framework.sf_el_ux.deprecation_warning}" === "module.framework.sf_el_ux.deprecation_warning.disabled"
        </constraint>
        <requires interface="_rtos" />
        <provides interface="interface.framework.sf_el_ux" />
        <provides interface="interface.framework.sf_el_ux_on_sf_el_ux" />
        <provides interface="interface.framework.sf_el_ux.${module.framework.sf_el_ux.name}" />
        <property default="g_sf_el_ux" display="Name" id="module.framework.sf_el_ux.name" description="Module name.">
            <constraint display="Name must be a valid C symbol">testSymbol("${module.framework.sf_el_ux.name}")</constraint>
        </property>
        <property default="module.framework.sf_el_ux.deprecation_warning.enabled" display="Show deprecation warning" id="module.framework.sf_el_ux.deprecation_warning" description="Set this to disabled to hide the deprecation warning.">
            <option display="Enabled" id="module.framework.sf_el_ux.deprecation_warning.enabled" value="0"/>
            <option display="Disabled" id="module.framework.sf_el_ux.deprecation_warning.disabled" value="1"/>
        </property>
        <interrupt node="board.icu.usbfs.int" />
        <interrupt node="board.icu.usbhs.usb_int_resume" />
        <header>
            #include "sf_el_ux_cfg.h"
        </header>
        <declarations>
            #if (SF_EL_UX_HCD_CFG_HS_IRQ_IPL != BSP_IRQ_DISABLED)
            /* USBHS ISR vector registering. */
            #if !defined(SSP_SUPPRESS_ISR_${module.framework.sf_el_ux.name}) &amp;&amp; !defined(SSP_SUPPRESS_ISR_USB)
            SSP_VECTOR_DEFINE_UNIT(usbhs_usb_int_resume_isr, USB, HS, USB_INT_RESUME, 0);
            #endif
            #endif
            #if (SF_EL_UX_HCD_CFG_FS_IRQ_IPL != BSP_IRQ_DISABLED)
            /* USBFS ISR vector registering. */
            #if !defined(SSP_SUPPRESS_ISR_${module.framework.sf_el_ux.name}) &amp;&amp; !defined(SSP_SUPPRESS_ISR_USB)
            SSP_VECTOR_DEFINE_UNIT(usbfs_int_isr, USB, FS, INT, 0);
            #endif
            #endif
        </declarations>
    </module>

    <config id="config.framework.sf_el_ux_hcd_hs" path="ssp_cfg/framework/sf_el_ux_hcd_hs_cfg.h" version="0">
        <property default="" display="High Speed Interrupt Priority" id="config.framework.sf_el_ux_hcd_hs.irq_ipl" description="Select the interrupt priority for high speed USB.">
            <select enum="enum.mcu.nvic.priorities.optional"/>
        </property>
        <property default="config.framework.sf_el_ux_hcd_hs.fifo_size.normal" display="FIFO size for Bulk/Isochronous Pipes" id="config.framework.sf_el_ux_hcd_hs.fifo_size" description="Select the FIFO size for bulk and isochronous transfers.">
            <option display="512 bytes(default)" id="config.framework.sf_el_ux_hcd_hs.fifo_size.normal" value="(0)"/>
            <option display="1024 bytes"         id="config.framework.sf_el_ux_hcd_hs.fifo_size.double" value="(1024)"/>
            <option display="1536 bytes"         id="config.framework.sf_el_ux_hcd_hs.fifo_size.triple" value="(1536)"/>
            <option display="2048 bytes"         id="config.framework.sf_el_ux_hcd_hs.fifo_size.max"    value="(2048)"/>
        </property>
        <property default="config.framework.sf_el_ux_hcd_hs.bulk_pipe_start_index.pipe1" display="Number of Isochronous Pipes Reserved" id="config.framework.sf_el_ux_hcd_hs.bulk_pipe_start_index" description="Select the number of isochronous pipes to reserve.">
            <option display="0(default)" id="config.framework.sf_el_ux_hcd_hs.bulk_pipe_start_index.pipe1" value="(1UL)"/>
            <option display="1"          id="config.framework.sf_el_ux_hcd_hs.bulk_pipe_start_index.pipe2"  value="(2UL)"/>
            <option display="2"          id="config.framework.sf_el_ux_hcd_hs.bulk_pipe_start_index.pipe3"  value="(3UL)"/>
        </property>
        <property default="config.framework.sf_el_ux_hcd_hs.VBUSENpin_logic.active_high" display="VBUSEN pin Signal Logic" id="config.framework.sf_el_ux_hcd_hs.VBUSENpin_logic" description="Select the VBUSEN pin signal logic.">
            <option display="Active Low"  id="config.framework.sf_el_ux_hcd_hs.VBUSENpin_logic.active_low"  value="(1)"/>
            <option display="Active High" id="config.framework.sf_el_ux_hcd_hs.VBUSENpin_logic.active_high" value="(0)"/>
        </property>
        <property default="config.framework.sf_el_ux_hcd_hs.hs_bit.bitset_high" display="Enable High Speed" id="config.framework.sf_el_ux_hcd_hs.hs_bit" description="Select if high speed should be enabled.">
             <option display="Enable"  id="config.framework.sf_el_ux_hcd_hs.hs_bit.bitset_high" value="(1)"/>
             <option display="Disable" id="config.framework.sf_el_ux_hcd_hs.hs_bit.bitset_low" value="(0)"/>
        </property>
        <content>
            #include "sf_el_ux_cfg.h"

            #if ${config.framework.sf_el_ux_hcd_hs.fifo_size}
            #define UX_SYNERGY_MAX_BULK_PAYLOAD ${config.framework.sf_el_ux_hcd_hs.fifo_size}
            #define UX_SYNERGY_MAX_ISO_PAYLOAD  ${config.framework.sf_el_ux_hcd_hs.fifo_size}
            #endif

            #define UX_SYNERGY_BULK_PIPE_START_INDEX ${config.framework.sf_el_ux_hcd_hs.bulk_pipe_start_index}

            #if defined(UX_HOST_VBUS_ENABLE_LOW)
            #if !defined(UX_HOST_HS_VBUS_ENABLE_LOW)
            #define UX_HOST_HS_VBUS_ENABLE_LOW
            #endif
            #endif

            #if ${config.framework.sf_el_ux_hcd_hs.VBUSENpin_logic}
            #if !defined(UX_HOST_HS_VBUS_ENABLE_LOW)
            #define UX_HOST_HS_VBUS_ENABLE_LOW
            #endif
            #endif
            #if ( defined(BSP_BOARD_S7G2_SK) || defined(BSP_BOARD_S5D9_PK) || defined(BSP_BOARD_S5D9_ASK) )
            #ifndef UX_HOST_HS_VBUS_ENABLE_LOW
            #define UX_HOST_HS_VBUS_ENABLE_LOW
            #endif
            #endif

            #if (${config.framework.sf_el_ux_hcd_hs.hs_bit} == 0)
            #define UX_HOST_DISABLE_HS 
            #endif

            #if (SF_EL_UX_HCD_CFG_HS_IRQ_IPL == BSP_IRQ_DISABLED)
            #undef SF_EL_UX_HCD_CFG_HS_IRQ_IPL
            #define SF_EL_UX_HCD_CFG_HS_IRQ_IPL      ${config.framework.sf_el_ux_hcd_hs.irq_ipl}
            #define UX_HCD_SYNERY_USE_USBHS
            #endif
        </content>
    </config>

    <config id="config.framework.sf_el_ux_hcd_fs" path="ssp_cfg/framework/sf_el_ux_hcd_fs_cfg.h" version="0">
        <property default="" display="Full Speed Interrupt Priority" id="config.framework.sf_el_ux_hcd_fs.irq_ipl" description="Select the interrupt priority for full speed USB.">
            <select enum="enum.mcu.nvic.priorities.optional" />
        </property>
        <property default="config.framework.sf_el_ux_hcd_fs.VBUSENpin_logic.active_high" display="VBUSEN pin Signal Logic" id="config.framework.sf_el_ux_hcd_fs.VBUSENpin_logic" description="Select the VBUSEN pin signal logic.">
            <option display="Active Low"  id="config.framework.sf_el_ux_hcd_fs.VBUSENpin_logic.active_low"  value="(1)"/>
            <option display="Active High" id="config.framework.sf_el_ux_hcd_fs.VBUSENpin_logic.active_high" value="(0)"/>
        </property>
        <property default="config.framework.sf_el_ux_hcd_fs.VCC_LDO_Regulator.disabled" display="LDO Regulator(Only for S3 and S1 part MCUs)" id="config.framework.sf_el_ux_hcd_fs.VCC_LDO_Regulator" description="Select if the LDO regulator will be enabled.">
            <option display="Enable"  id="config.framework.sf_el_ux_hcd_fs.VCC_LDO_Regulator.enabled"  value="(1)"/>
            <option display="Disable" id="config.framework.sf_el_ux_hcd_fs.VCC_LDO_Regulator.disabled" value="(0)"/>
        </property>
        <content>
            #include "sf_el_ux_cfg.h"

            #if defined(UX_HOST_VBUS_ENABLE_LOW)
            #if !defined(UX_HOST_FS_VBUS_ENABLE_LOW)
            #define UX_HOST_FS_VBUS_ENABLE_LOW
            #endif
            #endif

            #if ${config.framework.sf_el_ux_hcd_fs.VBUSENpin_logic}
            #if !defined(UX_HOST_FS_VBUS_ENABLE_LOW)
            #define UX_HOST_FS_VBUS_ENABLE_LOW
            #endif
            #endif
            #if ( defined(BSP_BOARD_S7G2_SK) || defined(BSP_BOARD_S5D9_PK) || defined(BSP_BOARD_S5D9_ASK) )
            #ifndef UX_HOST_FS_VBUS_ENABLE_LOW
            #define UX_HOST_FS_VBUS_ENABLE_LOW
            #endif
            #endif
            
            #if (SF_EL_UX_HCD_CFG_FS_IRQ_IPL == BSP_IRQ_DISABLED)
            #undef SF_EL_UX_HCD_CFG_FS_IRQ_IPL
            #define SF_EL_UX_HCD_CFG_FS_IRQ_IPL      ${config.framework.sf_el_ux_hcd_fs.irq_ipl}
            #endif
            
            #if ${config.framework.sf_el_ux_hcd_fs.VCC_LDO_Regulator}
            #if ( defined(BSP_MCU_GROUP_S3A7) || defined(BSP_MCU_GROUP_S3A3) || defined(BSP_MCU_GROUP_S3A6) )
            #ifndef UX_HCD_FS_LDO_ENABLE
            #define UX_HCD_FS_LDO_ENABLE
            #endif
            #endif
            #endif
        </content>
    </config>

    <config id="config.framework.sf_el_ux_dcd_hs" path="ssp_cfg/framework/sf_el_ux_dcd_hs_cfg.h" version="0">
        <property default="" display="High Speed Interrupt Priority" id="config.framework.sf_el_ux_dcd_hs.irq_ipl" description="Select the interrupt priority for high speed USB.">
            <select enum="enum.mcu.nvic.priorities.optional" />
        </property>
        <content>
            #include "sf_el_ux_cfg.h"

            #if (SF_EL_UX_DCD_CFG_HS_IRQ_IPL == BSP_IRQ_DISABLED)
            #undef SF_EL_UX_DCD_CFG_HS_IRQ_IPL
            #define SF_EL_UX_DCD_CFG_HS_IRQ_IPL      ${config.framework.sf_el_ux_dcd_hs.irq_ipl}
            #define UX_DCD_SYNERY_USE_USBHS
            #endif
        </content>
    </config>

    <config id="config.framework.sf_el_ux_dcd_fs" path="ssp_cfg/framework/sf_el_ux_dcd_fs_cfg.h" version="0">
        <property default="" display="Full Speed Interrupt Priority" id="config.framework.sf_el_ux_dcd_fs.irq_ipl" description="Select the interrupt priority for full speed USB.">
            <select enum="enum.mcu.nvic.priorities.optional"/>
        </property>
        <property default="config.framework.sf_el_ux_dcd_fs.VCC_LDO_Regulator.disabled" display="LDO Regulator(Only for S3 and S1 part MCUs)" id="config.framework.sf_el_ux_dcd_fs.VCC_LDO_Regulator" description="Select if the LDO regulator will be enabled.">
            <option display="Enable"  id="config.framework.sf_el_ux_dcd_fs.VCC_LDO_Regulator.enabled"  value="(1)"/>
            <option display="Disable" id="config.framework.sf_el_ux_dcd_fs.VCC_LDO_Regulator.disabled" value="(0)"/>
        </property>
        <content>
            #include "sf_el_ux_cfg.h"

            #if (SF_EL_UX_DCD_CFG_FS_IRQ_IPL == BSP_IRQ_DISABLED)
            #undef SF_EL_UX_DCD_CFG_FS_IRQ_IPL
            #define SF_EL_UX_DCD_CFG_FS_IRQ_IPL      ${config.framework.sf_el_ux_dcd_fs.irq_ipl}
            #endif
            
            #if ${config.framework.sf_el_ux_dcd_fs.VCC_LDO_Regulator}
            #if ( defined(BSP_MCU_GROUP_S124) || defined(BSP_MCU_GROUP_S128) || defined(BSP_MCU_GROUP_S1JA) || defined(BSP_MCU_GROUP_S3A7) || defined(BSP_MCU_GROUP_S3A3) || defined(BSP_MCU_GROUP_S3A6) )
            #ifndef UX_DCD_FS_LDO_ENABLE
            #define UX_DCD_FS_LDO_ENABLE
            #endif
            #endif
            #endif
        </content>
    </config>

    <module config="config.framework.sf_el_ux_hcd_hs" display="X-Ware|USBX|Host|Synergy Port|${module.framework.sf_el_ux_hcd.name} USBX Port HCD on sf_el_ux for USBHS" common="1" id="module.framework.sf_el_ux_hcd_hs" version="1" url="http://knowledgebase.renesas.com/English_Content/Renesas_Synergy%E2%84%A2_Platform/Renesas_Synergy_Knowledge_Base/sf_el_ux_Module_Guide_Resources">
        <constraint display="Module instances must have unique names">
            "${interface.framework.sf_el_ux_hcd.${module.framework.sf_el_ux_hcd.name}}" === "1"
        </constraint>
        <constraint display="Requires USBX Interrupt (USBHS USBIR) enabled">
            ("${config.framework.sf_el_ux_hcd_hs.irq_ipl}" != "board.icu.common.irq.disabled")
        </constraint>
        <constraint display="The USB controller is used for USB device">
            "${interface.framework.sf_el_ux_dcd.R_USBHS_BASE}" != "1"
        </constraint>
        <constraint display="Requires USB High Speed peripheral">
          "${interface.mcu.usb_hs.external}" === "1"
        </constraint>
        <requires interface="interface.mcu.usb_hs.external" visible="false" display="Requires USB High Speed hardware" />
        <requires interface="_rtos" />
        <requires id="module.framework.sf_el_ux_hcd.requires.transfer_tx" interface="interface.driver.transfer" display="Add Transfer Module TX [Recommended but optional]">
            <override property="module.driver.transfer.size" value="module.driver.transfer.size.size_1_byte"/>
            <override property="module.driver.transfer.mode" value="module.driver.transfer.mode.mode_block"/>
            <override property="module.driver.transfer.dest_addr_mode" value="module.driver.transfer.dest_addr_mode.addr_mode_fixed"/>
            <override property="module.driver.transfer.src_addr_mode" value="module.driver.transfer.src_addr_mode.addr_mode_incremented"/>
            <override property="module.driver.transfer.repeat_area" value="module.driver.transfer.repeat_area.repeat_area_source"/>
            <override property="module.driver.transfer.p_dest" value="NULL"/>
            <override property="module.driver.transfer.p_src" value="NULL"/>
            <override property="module.driver.transfer.length" value="0"/>
            <override property="module.driver.transfer.interrupt" value="module.driver.transfer.interrupt.interrupt_end"/>
            <override property="module.driver.transfer.num_blocks" value="0"/>
            <override property="module.driver.transfer.auto_enable" value="module.driver.transfer.auto_enable.false"/>
            <override property="module.driver.transfer.p_callback" value="NULL"/>
            <override property="module.driver.transfer.activation_source" value="module.driver.transfer.event.event_elc_software_event_0"/>
        </requires>
        <requires id="module.framework.sf_el_ux_hcd.requires.transfer_rx" interface="interface.driver.transfer" display="Add Transfer Module RX [Recommended but optional]">
            <override property="module.driver.transfer.size" value="module.driver.transfer.size.size_1_byte"/>
            <override property="module.driver.transfer.mode" value="module.driver.transfer.mode.mode_block"/>
            <override property="module.driver.transfer.dest_addr_mode" value="module.driver.transfer.dest_addr_mode.addr_mode_incremented"/>
            <override property="module.driver.transfer.src_addr_mode" value="module.driver.transfer.src_addr_mode.addr_mode_fixed"/>
            <override property="module.driver.transfer.repeat_area" value="module.driver.transfer.repeat_area.repeat_area_destination"/>
            <override property="module.driver.transfer.p_dest" value="NULL"/>
            <override property="module.driver.transfer.p_src" value="NULL"/>
            <override property="module.driver.transfer.length" value="0"/>
            <override property="module.driver.transfer.interrupt" value="module.driver.transfer.interrupt.interrupt_end"/>
            <override property="module.driver.transfer.num_blocks" value="0"/>
            <override property="module.driver.transfer.auto_enable" value="module.driver.transfer.auto_enable.false"/>
            <override property="module.driver.transfer.p_callback" value="NULL"/>
            <override property="module.driver.transfer.activation_source" value="module.driver.transfer.event.event_elc_software_event_1"/>
        </requires>
        <provides interface="interface.framework.sf_el_ux_hcd" />
        <provides interface="interface.framework.sf_el_ux_hcd.${module.framework.sf_el_ux_hcd.name}" />
        <provides interface="interface.framework.sf_el_ux_hcd.R_USBHS_BASE" />
        <property default="g_sf_el_ux_hcd_hs_${_instance}" display="Name" id="module.framework.sf_el_ux_hcd.name" description="Module name.">
            <constraint display="Name must be a valid C symbol">testSymbol("${module.framework.sf_el_ux_hcd.name}")</constraint>
        </property>
        <property default="R_USBHS_BASE" display="USB Controller Selection" id="module.framework.sf_el_ux_hcd.hw_address" description="Select the USB controller.">
            <option display="USBHS" id="module.framework.sf_el_ux_hcd.hw_address.hs" value="R_USBHS_BASE" />
        </property>
        <header>
            #include "ux_api.h"
            #include "ux_hcd_synergy.h"
            #include "sf_el_ux_hcd_hs_cfg.h"
        </header>
        <declarations>

            /***********************************************************************************************************************
             * Registers Interrupt Vector for USBHS Controller.
             **********************************************************************************************************************/
            #if (SF_EL_UX_HCD_CFG_HS_IRQ_IPL != BSP_IRQ_DISABLED)
            /* USBHS ISR vector registering. */
            #if !defined(SSP_SUPPRESS_ISR_${module.framework.sf_el_ux_hcd.name}) &amp;&amp; !defined(SSP_SUPPRESS_ISR_USB)
            SSP_VECTOR_DEFINE_UNIT(usbhs_usb_int_resume_isr, USB, HS, USB_INT_RESUME, 0);
            #endif
            #endif

            #undef SYNERGY_NOT_DEFINED
            #define SYNERGY_NOT_DEFINED (1)
            /***********************************************************************************************************************
             * The definition of wrapper interface for USBX Synergy Port HCD Driver.
             **********************************************************************************************************************/
            static UINT ${module.framework.sf_el_ux_hcd.name}_initialize(UX_HCD *hcd)
            {
            #if ((SYNERGY_NOT_DEFINED != ${module.framework.sf_el_ux_hcd.requires.transfer_tx::module.driver.transfer.name}) &amp;&amp; (SYNERGY_NOT_DEFINED != ${module.framework.sf_el_ux_hcd.requires.transfer_rx::module.driver.transfer.name}))
                /* DMA support */
                UX_HCD_SYNERGY_TRANSFER hcd_transfer;
                hcd_transfer.ux_synergy_transfer_tx = (transfer_instance_t *)&amp;${module.framework.sf_el_ux_hcd.requires.transfer_tx::module.driver.transfer.name};
                hcd_transfer.ux_synergy_transfer_rx = (transfer_instance_t *)&amp;${module.framework.sf_el_ux_hcd.requires.transfer_rx::module.driver.transfer.name};
                return (UINT)ux_hcd_synergy_initialize_transfer_support(hcd, (UX_HCD_SYNERGY_TRANSFER *)&amp;hcd_transfer);
            #else
                /* Non DMA support */
                return (UINT)ux_hcd_synergy_initialize(hcd);
            #endif
            }  /* End of function ${module.framework.sf_el_ux_hcd.name}_initialize() */
            #undef SYNERGY_NOT_DEFINED

        </declarations>
    </module>

    <module config="config.framework.sf_el_ux_hcd_fs" display="X-Ware|USBX|Host|Synergy Port|${module.framework.sf_el_ux_hcd.name} USBX Port HCD on sf_el_ux for USBFS" common="1" id="module.framework.sf_el_ux_hcd_fs" version="1" url="http://knowledgebase.renesas.com/English_Content/Renesas_Synergy%E2%84%A2_Platform/Renesas_Synergy_Knowledge_Base/sf_el_ux_Module_Guide_Resources">
        <constraint display="Module instances must have unique names">
            "${interface.framework.sf_el_ux_hcd.${module.framework.sf_el_ux_hcd.name}}" === "1"
        </constraint>
        <constraint display="Requires USBX Interrupt (USBFS USBI) enabled">
            ("${config.framework.sf_el_ux_hcd_fs.irq_ipl}" != "board.icu.common.irq.disabled")
        </constraint>
        <constraint display="The USB controller is used for USB device">
            "${interface.framework.sf_el_ux_dcd.R_USBFS_BASE}" != "1"
        </constraint>
        <constraint display="Requires USB Full Speed peripheral">
          "${interface.mcu.usb_fs.external}" === "1"
        </constraint>
        <requires interface="interface.mcu.usb_fs.external" visible="false" display="Requires USB Full Speed hardware" />
        <requires interface="_rtos" />
        <requires id="module.framework.sf_el_ux_hcd_fs.requires.transfer_tx" interface="interface.driver.transfer" display="Add Transfer Module TX [Recommended but optional]">
            <override property="module.driver.transfer.size" value="module.driver.transfer.size.size_1_byte"/>
            <override property="module.driver.transfer.mode" value="module.driver.transfer.mode.mode_block"/>
            <override property="module.driver.transfer.dest_addr_mode" value="module.driver.transfer.dest_addr_mode.addr_mode_fixed"/>
            <override property="module.driver.transfer.src_addr_mode" value="module.driver.transfer.src_addr_mode.addr_mode_incremented"/>
            <override property="module.driver.transfer.repeat_area" value="module.driver.transfer.repeat_area.repeat_area_source"/>
            <override property="module.driver.transfer.p_dest" value="NULL"/>
            <override property="module.driver.transfer.p_src" value="NULL"/>
            <override property="module.driver.transfer.length" value="0"/>
            <override property="module.driver.transfer.interrupt" value="module.driver.transfer.interrupt.interrupt_end"/>
            <override property="module.driver.transfer.num_blocks" value="0"/>
            <override property="module.driver.transfer.auto_enable" value="module.driver.transfer.auto_enable.false"/>
            <override property="module.driver.transfer.p_callback" value="NULL"/>
            <override property="module.driver.transfer.activation_source" value="module.driver.transfer.event.event_elc_software_event_0"/>
        </requires>
        <requires id="module.framework.sf_el_ux_hcd_fs.requires.transfer_rx" interface="interface.driver.transfer" display="Add Transfer Module RX [Recommended but optional]">
            <override property="module.driver.transfer.size" value="module.driver.transfer.size.size_1_byte"/>
            <override property="module.driver.transfer.mode" value="module.driver.transfer.mode.mode_block"/>
            <override property="module.driver.transfer.dest_addr_mode" value="module.driver.transfer.dest_addr_mode.addr_mode_incremented"/>
            <override property="module.driver.transfer.src_addr_mode" value="module.driver.transfer.src_addr_mode.addr_mode_fixed"/>
            <override property="module.driver.transfer.repeat_area" value="module.driver.transfer.repeat_area.repeat_area_destination"/>
            <override property="module.driver.transfer.p_dest" value="NULL"/>
            <override property="module.driver.transfer.p_src" value="NULL"/>
            <override property="module.driver.transfer.length" value="0"/>
            <override property="module.driver.transfer.interrupt" value="module.driver.transfer.interrupt.interrupt_end"/>
            <override property="module.driver.transfer.num_blocks" value="0"/>
            <override property="module.driver.transfer.auto_enable" value="module.driver.transfer.auto_enable.false"/>
            <override property="module.driver.transfer.p_callback" value="NULL"/>
            <override property="module.driver.transfer.activation_source" value="module.driver.transfer.event.event_elc_software_event_1"/>
        </requires>
        <provides interface="interface.framework.sf_el_ux_hcd" />
        <provides interface="interface.framework.sf_el_ux_hcd.${module.framework.sf_el_ux_hcd.name}" />
        <provides interface="interface.framework.sf_el_ux_hcd.R_USBFS_BASE" />
        <property default="g_sf_el_ux_hcd_fs_${_instance}" display="Name" id="module.framework.sf_el_ux_hcd.name" description="Module name.">
            <constraint display="Name must be a valid C symbol">testSymbol("${module.framework.sf_el_ux_hcd.name}")</constraint>
        </property>
        <property default="R_USBFS_BASE" display="USB Controller Selection" id="module.framework.sf_el_ux_hcd.hw_address" description="Select the USB controller.">
            <option display="USBFS" id="module.framework.sf_el_ux_hcd.hw_address.fs" value="R_USBFS_BASE" />
        </property>
        <header>
            #include "ux_api.h"
            #include "ux_hcd_synergy.h"
            #include "sf_el_ux_hcd_fs_cfg.h"
        </header>
        <declarations>

            /***********************************************************************************************************************
             * Registers Interrupt Vector for USBFS Controller.
             **********************************************************************************************************************/
            #if (SF_EL_UX_HCD_CFG_FS_IRQ_IPL != BSP_IRQ_DISABLED)
            /* USBFS ISR vector registering. */
            #if !defined(SSP_SUPPRESS_ISR_${module.framework.sf_el_ux_hcd.name}) &amp;&amp; !defined(SSP_SUPPRESS_ISR_USB)
            SSP_VECTOR_DEFINE_UNIT(usbfs_int_isr, USB, FS, INT, 0);
            #endif
            #endif

            #undef SYNERGY_NOT_DEFINED
            #define SYNERGY_NOT_DEFINED (1)
            /***********************************************************************************************************************
             * The definition of wrapper interface for USBX Synergy Port HCD Driver.
             **********************************************************************************************************************/
            static UINT ${module.framework.sf_el_ux_hcd.name}_initialize(UX_HCD *hcd)
            {
            #if ((SYNERGY_NOT_DEFINED != ${module.framework.sf_el_ux_hcd_fs.requires.transfer_tx::module.driver.transfer.name}) &amp;&amp; (SYNERGY_NOT_DEFINED != ${module.framework.sf_el_ux_hcd_fs.requires.transfer_rx::module.driver.transfer.name}))
                /* DMA support */
                UX_HCD_SYNERGY_TRANSFER hcd_transfer;
                hcd_transfer.ux_synergy_transfer_tx = (transfer_instance_t *)&amp;${module.framework.sf_el_ux_hcd_fs.requires.transfer_tx::module.driver.transfer.name};
                hcd_transfer.ux_synergy_transfer_rx = (transfer_instance_t *)&amp;${module.framework.sf_el_ux_hcd_fs.requires.transfer_rx::module.driver.transfer.name};
                return (UINT)ux_hcd_synergy_initialize_transfer_support(hcd, (UX_HCD_SYNERGY_TRANSFER *)&amp;hcd_transfer);
            #else
                /* Non DMA support */
                return (UINT)ux_hcd_synergy_initialize(hcd);
            #endif
            }  /* End of function ${module.framework.sf_el_ux_hcd.name}_initialize() */
            #undef SYNERGY_NOT_DEFINED

        </declarations>
    </module>

    <module config="config.framework.sf_el_ux_dcd_hs" display="X-Ware|USBX|Device|Synergy Port|${module.framework.sf_el_ux_dcd_hs.name} USBX Port DCD on sf_el_ux for USBHS" id="module.framework.sf_el_ux_dcd_hs" common="1" version="1" url="http://knowledgebase.renesas.com/English_Content/Renesas_Synergy%E2%84%A2_Platform/Renesas_Synergy_Knowledge_Base/sf_el_ux_Module_Guide_Resources">
        <constraint display="Module instances must have unique names">
            "${interface.framework.sf_el_ux_dcd.${module.framework.sf_el_ux_dcd_hs.name}}" === "1"
        </constraint>
        <constraint display="Requires USBX Interrupt (USBHS USBIR) enabled">
            ("${config.framework.sf_el_ux_dcd_hs.irq_ipl}" != "board.icu.common.irq.disabled")
        </constraint>
        <constraint display="The USB controller is used for USB host">
            "${interface.framework.sf_el_ux_hcd.R_USBHS_BASE}" != "1"
        </constraint>
        <constraint display="Requires the use of Transfer modules for both of TX and RX or neither">
            ((testExists("${module.framework.sf_el_ux_dcd_hs.requires.transfer_tx::module.driver.transfer.name}") === true) &amp;&amp; (testExists("${module.framework.sf_el_ux_dcd_hs.requires.transfer_rx::module.driver.transfer.name}") === true)) || ((testExists("${module.framework.sf_el_ux_dcd_hs.requires.transfer_tx::module.driver.transfer.name}") === false) &amp;&amp;(testExists("${module.framework.sf_el_ux_dcd_hs.requires.transfer_rx::module.driver.transfer.name}") === false))
        </constraint>
        <constraint display="Requires Transfer module (TX) Interrupt enabled">
            (testExists("${module.framework.sf_el_ux_dcd_hs.requires.transfer_tx::module.driver.transfer.name}") === false) || (testExists("${module.framework.sf_el_ux_dcd_hs.requires.transfer_tx::module.driver.transfer.name}") &amp;&amp; ("${module.framework.sf_el_ux_dcd_hs.requires.transfer_tx::module.driver.transfer.irq_ipl}" != "board.icu.common.irq.disabled"))
        </constraint>
        <constraint display="Requires Transfer module (RX) Interrupt enabled">
            (testExists("${module.framework.sf_el_ux_dcd_hs.requires.transfer_rx::module.driver.transfer.name}") === false) || (testExists("${module.framework.sf_el_ux_dcd_hs.requires.transfer_rx::module.driver.transfer.name}") &amp;&amp; ("${module.framework.sf_el_ux_dcd_hs.requires.transfer_rx::module.driver.transfer.irq_ipl}" != "board.icu.common.irq.disabled"))
        </constraint>
        <constraint display="Requires Interrupt Priority of Transfer module (TX) must be higher than USB's">
            (testExists("${module.framework.sf_el_ux_dcd_hs.requires.transfer_tx::module.driver.transfer.name}") === false) || (testExists("${module.framework.sf_el_ux_dcd_hs.requires.transfer_tx::module.driver.transfer.name}") &amp;&amp; ("${config.framework.sf_el_ux_dcd_hs.irq_ipl}" &gt; "${module.framework.sf_el_ux_dcd_hs.requires.transfer_tx::module.driver.transfer.irq_ipl}"))
        </constraint>
        <constraint display="Requires Interrupt Priority of Transfer module (RX) must be higher than USB's">
            (testExists("${module.framework.sf_el_ux_dcd_hs.requires.transfer_rx::module.driver.transfer.name}") === false) || (testExists("${module.framework.sf_el_ux_dcd_hs.requires.transfer_rx::module.driver.transfer.name}") &amp;&amp; ("${config.framework.sf_el_ux_dcd_hs.irq_ipl}" &gt; "${module.framework.sf_el_ux_dcd_hs.requires.transfer_rx::module.driver.transfer.irq_ipl}"))
        </constraint>
        <constraint display="Requires USB High Speed peripheral">
          "${interface.mcu.usb_hs.external}" === "1"
        </constraint>

        <requires interface="interface.mcu.usb_hs.external" visible="false" display="Requires USB High Speed hardware" />
        <requires interface="_rtos" />
        <requires id="module.framework.sf_el_ux_dcd_hs.requires.transfer_tx" interface="interface.driver.transfer" display="Add Transfer Module for TX [Recommended but optional]">
            <override property="module.driver.transfer.size" value="module.driver.transfer.size.size_1_byte"/>
            <override property="module.driver.transfer.mode" value="module.driver.transfer.mode.mode_block"/>
            <override property="module.driver.transfer.dest_addr_mode" value="module.driver.transfer.dest_addr_mode.addr_mode_fixed"/>
            <override property="module.driver.transfer.src_addr_mode" value="module.driver.transfer.src_addr_mode.addr_mode_incremented"/>
            <override property="module.driver.transfer.repeat_area" value="module.driver.transfer.repeat_area.repeat_area_source"/>
            <override property="module.driver.transfer.p_dest" value="NULL"/>
            <override property="module.driver.transfer.p_src" value="NULL"/>
            <override property="module.driver.transfer.length" value="0"/>
            <override property="module.driver.transfer.interrupt" value="module.driver.transfer.interrupt.interrupt_end"/>
            <override property="module.driver.transfer.num_blocks" value="0"/>
            <override property="module.driver.transfer.auto_enable" value="module.driver.transfer.auto_enable.false"/>
            <override property="module.driver.transfer.p_callback" value="NULL"/>
            <override property="module.driver.transfer.activation_source" value="module.driver.transfer.event.event_usbhs_fifo_0"/>
        </requires>
        <requires id="module.framework.sf_el_ux_dcd_hs.requires.transfer_rx" interface="interface.driver.transfer" display="Add Transfer Module for RX [Recommended but optional]">
            <override property="module.driver.transfer.size" value="module.driver.transfer.size.size_1_byte"/>
            <override property="module.driver.transfer.mode" value="module.driver.transfer.mode.mode_block"/>
            <override property="module.driver.transfer.dest_addr_mode" value="module.driver.transfer.dest_addr_mode.addr_mode_incremented"/>
            <override property="module.driver.transfer.src_addr_mode" value="module.driver.transfer.src_addr_mode.addr_mode_fixed"/>
            <override property="module.driver.transfer.repeat_area" value="module.driver.transfer.repeat_area.repeat_area_destination"/>
            <override property="module.driver.transfer.p_dest" value="NULL"/>
            <override property="module.driver.transfer.p_src" value="NULL"/>
            <override property="module.driver.transfer.length" value="0"/>
            <override property="module.driver.transfer.interrupt" value="module.driver.transfer.interrupt.interrupt_end"/>
            <override property="module.driver.transfer.num_blocks" value="0"/>
            <override property="module.driver.transfer.auto_enable" value="module.driver.transfer.auto_enable.false"/>
            <override property="module.driver.transfer.p_callback" value="NULL"/>
            <override property="module.driver.transfer.activation_source" value="module.driver.transfer.event.event_usbhs_fifo_1"/>
        </requires>
        <provides interface="interface.framework.sf_el_ux_dcd" />
        <provides interface="interface.framework.sf_el_ux_dcd.${module.framework.sf_el_ux_dcd_hs.name}" />
        <provides interface="interface.framework.sf_el_ux_dcd.R_USBHS_BASE" />
        <property default="g_sf_el_ux_dcd_hs_${_instance}" display="Name" id="module.framework.sf_el_ux_dcd_hs.name" description="Module name.">
            <constraint display="Name must be a valid C symbol">testSymbol("${module.framework.sf_el_ux_dcd_hs.name}")</constraint>
        </property>
        <property default="R_USBHS_BASE" display="USB Controller Selection" id="module.framework.sf_el_ux_dcd_hs.hw_address" description="Select the USB controller.">
            <option display="USBHS" id="module.framework.sf_el_ux_dcd_hs.hw_address.fs" value="R_USBHS_BASE" />
        </property>
        <header>
            #include "ux_api.h"
            #include "ux_dcd_synergy.h"
            #include "sf_el_ux_dcd_hs_cfg.h"
            void ${module.framework.sf_el_ux_dcd_hs.name}_err_callback(void * p_instance, void * p_data);
        </header>
        <declarations>

            #if defined(__ICCARM__)
            #define ${module.framework.sf_el_ux_dcd_hs.name}_err_callback_WEAK_ATTRIBUTE
            #pragma weak ${module.framework.sf_el_ux_dcd_hs.name}_err_callback  = ${module.framework.sf_el_ux_dcd_hs.name}_err_callback_internal
            #elif defined(__GNUC__)
            #define ${module.framework.sf_el_ux_dcd_hs.name}_err_callback_WEAK_ATTRIBUTE   __attribute__ ((weak, alias("${module.framework.sf_el_ux_dcd_hs.name}_err_callback_internal")))
            #endif
            void ${module.framework.sf_el_ux_dcd_hs.name}_err_callback(void * p_instance, void * p_data) ${module.framework.sf_el_ux_dcd_hs.name}_err_callback_WEAK_ATTRIBUTE;
            #if (SF_EL_UX_CFG_HS_IRQ_IPL != BSP_IRQ_DISABLED)
            /* USBHS ISR vector registering. */
            #if !defined(SSP_SUPPRESS_ISR_${module.framework.sf_el_ux_dcd_hs.name}) &amp;&amp; !defined(SSP_SUPPRESS_ISR_USB)
            SSP_VECTOR_DEFINE_UNIT(usbhs_usb_int_resume_isr, USB, HS, USB_INT_RESUME, 0);
            #endif
            #endif

            /* Build-time constraint for non-supported configuration. */
            #if (BSP_CFG_MCU_PART_SERIES == 0x1)
             #warning "This MCU part does not have a USBHS port. Check sf_el_ux module configuration."
            #endif

            /* Prototype function for USBX DCD Initializer. */
            static void ux_dcd_initialize(void);

            #undef SYNERGY_NOT_DEFINED
            #define SYNERGY_NOT_DEFINED (1)
             /*******************************************************************************************************************//**
             * @brief      This is a weak example initialization error function.  It should be overridden by defining a user  function 
             *             with the prototype below.
             *             - void ${module.framework.sf_el_ux_dcd_hs.name}_err_callback(void * p_instance, void * p_data)
             *
             * @param[in]  p_instance arguments used to identify which instance caused the error and p_data Callback arguments used to identify what error caused the callback.
             **********************************************************************************************************************/
            void ${module.framework.sf_el_ux_dcd_hs.name}_err_callback_internal(void * p_instance, void * p_data);
            void ${module.framework.sf_el_ux_dcd_hs.name}_err_callback_internal(void * p_instance, void * p_data)
            {
              /** Suppress compiler warning for not using parameters. */
              SSP_PARAMETER_NOT_USED(p_instance);
              SSP_PARAMETER_NOT_USED(p_data);

              /** An error has occurred. Please check function arguments for more information. */
              BSP_CFG_HANDLE_UNRECOVERABLE_ERROR(0);
            }
            #if ((SYNERGY_NOT_DEFINED != ${module.framework.sf_el_ux_dcd_hs.requires.transfer_tx::module.driver.transfer.name}) &amp;&amp; (SYNERGY_NOT_DEFINED != ${module.framework.sf_el_ux_dcd_hs.requires.transfer_rx::module.driver.transfer.name}))
            /***********************************************************************************************************************
             * The definition of wrapper interface for USBX Synergy Port DCD Driver to get a transfer module instance.
             **********************************************************************************************************************/
            static UINT ${module.framework.sf_el_ux_dcd_hs.name}_initialize_transfer_support(ULONG dcd_io)
            {
                UX_DCD_SYNERGY_TRANSFER dcd_transfer;
                dcd_transfer.ux_synergy_transfer_tx = (transfer_instance_t *)&amp;${module.framework.sf_el_ux_dcd_hs.requires.transfer_tx::module.driver.transfer.name};
                dcd_transfer.ux_synergy_transfer_rx = (transfer_instance_t *)&amp;${module.framework.sf_el_ux_dcd_hs.requires.transfer_rx::module.driver.transfer.name};
                return (UINT)ux_dcd_synergy_initialize_transfer_support(dcd_io, (UX_DCD_SYNERGY_TRANSFER *)&amp;dcd_transfer);
            }  /* End of function ${module.framework.sf_el_ux_dcd_hs.name}_initialize_transfer_support() */
            #endif

            /***********************************************************************************************************************
             * Initializes USBX Device Controller Driver.
             **********************************************************************************************************************/
            void ux_dcd_initialize(void)
            {
                UINT status;
                /* Initializes the USB device controller, enabling DMA transfer if transfer module instances are given. */
                #if ((SYNERGY_NOT_DEFINED == ${module.framework.sf_el_ux_dcd_hs.requires.transfer_tx::module.driver.transfer.name}) || (SYNERGY_NOT_DEFINED == ${module.framework.sf_el_ux_dcd_hs.requires.transfer_rx::module.driver.transfer.name}))
                status = (UINT)ux_dcd_synergy_initialize(R_USBHS_BASE);
                #else
                status = ${module.framework.sf_el_ux_dcd_hs.name}_initialize_transfer_support(R_USBHS_BASE);
                #endif
                #undef SYNERGY_NOT_DEFINED
                if (UX_SUCCESS != status)
                {
                    ${module.framework.sf_el_ux_dcd_hs.name}_err_callback(NULL,&amp;status);
                }
             }  /* End of function ux_dcd_initialize() */
        </declarations>
    </module>

    <module config="config.framework.sf_el_ux_dcd_fs" display="X-Ware|USBX|Device|Synergy Port|${module.framework.sf_el_ux_dcd_fs.name} USBX Port DCD on sf_el_ux for USBFS" id="module.framework.sf_el_ux_dcd_fs" common="1" version="1" url="http://knowledgebase.renesas.com/English_Content/Renesas_Synergy%E2%84%A2_Platform/Renesas_Synergy_Knowledge_Base/sf_el_ux_Module_Guide_Resources">
        <constraint display="Module instances must have unique names">
            "${interface.framework.sf_el_ux_dcd.${module.framework.sf_el_ux_dcd_fs.name}}" === "1"
        </constraint>
        <constraint display="Requires USBX Interrupt (USBFS USBI) enabled">
            ("${config.framework.sf_el_ux_dcd_fs.irq_ipl}" != "board.icu.common.irq.disabled")
        </constraint>
        <constraint display="The USB controller is used for USB host">
            "${interface.framework.sf_el_ux_hcd.R_USBFS_BASE}" != "1"
        </constraint>
        <constraint display="Requires the use of Transfer modules for both of TX and RX or neither">
            ((testExists("${module.framework.sf_el_ux_dcd_fs.requires.transfer_tx::module.driver.transfer.name}") === true) &amp;&amp; (testExists("${module.framework.sf_el_ux_dcd_fs.requires.transfer_rx::module.driver.transfer.name}") === true)) || ((testExists("${module.framework.sf_el_ux_dcd_fs.requires.transfer_tx::module.driver.transfer.name}") === false) &amp;&amp;(testExists("${module.framework.sf_el_ux_dcd_fs.requires.transfer_rx::module.driver.transfer.name}") === false))
        </constraint>
        <constraint display="Requires Transfer module (TX) Interrupt enabled">
            (testExists("${module.framework.sf_el_ux_dcd_fs.requires.transfer_tx::module.driver.transfer.name}") === false) || (testExists("${module.framework.sf_el_ux_dcd_fs.requires.transfer_tx::module.driver.transfer.name}") &amp;&amp; ("${module.framework.sf_el_ux_dcd_fs.requires.transfer_tx::module.driver.transfer.irq_ipl}" != "board.icu.common.irq.disabled"))
        </constraint>
        <constraint display="Requires Transfer module (RX) Interrupt enabled">
            (testExists("${module.framework.sf_el_ux_dcd_fs.requires.transfer_rx::module.driver.transfer.name}") === false) || (testExists("${module.framework.sf_el_ux_dcd_fs.requires.transfer_rx::module.driver.transfer.name}") &amp;&amp; ("${module.framework.sf_el_ux_dcd_fs.requires.transfer_rx::module.driver.transfer.irq_ipl}" != "board.icu.common.irq.disabled"))
        </constraint>
        <constraint display="Requires Interrupt Priority of Transfer module (TX) must be higher than USB's">
            (testExists("${module.framework.sf_el_ux_dcd_fs.requires.transfer_tx::module.driver.transfer.name}") === false) || (testExists("${module.framework.sf_el_ux_dcd_fs.requires.transfer_tx::module.driver.transfer.name}") &amp;&amp; ("${config.framework.sf_el_ux_dcd_fs.irq_ipl}" &gt; "${module.framework.sf_el_ux_dcd_fs.requires.transfer_tx::module.driver.transfer.irq_ipl}"))
        </constraint>
        <constraint display="Requires Interrupt Priority of Transfer module (RX) must be higher than USB's">
            (testExists("${module.framework.sf_el_ux_dcd_fs.requires.transfer_rx::module.driver.transfer.name}") === false) || (testExists("${module.framework.sf_el_ux_dcd_fs.requires.transfer_rx::module.driver.transfer.name}") &amp;&amp; ("${config.framework.sf_el_ux_dcd_fs.irq_ipl}" &gt; "${module.framework.sf_el_ux_dcd_fs.requires.transfer_rx::module.driver.transfer.irq_ipl}"))
        </constraint>
        <constraint display="Requires USB Full Speed peripheral">
          "${interface.mcu.usb_fs.external}" === "1"
        </constraint>

        <requires interface="interface.mcu.usb_fs.external" visible="false" display="Requires USB Full Speed hardware" />
        <requires interface="_rtos" />
        <requires id="module.framework.sf_el_ux_dcd_fs.requires.transfer_tx" interface="interface.driver.transfer" display="Add Transfer Module for TX [Recommended but optional]">
            <override property="module.driver.transfer.size" value="module.driver.transfer.size.size_1_byte"/>
            <override property="module.driver.transfer.mode" value="module.driver.transfer.mode.mode_block"/>
            <override property="module.driver.transfer.dest_addr_mode" value="module.driver.transfer.dest_addr_mode.addr_mode_fixed"/>
            <override property="module.driver.transfer.src_addr_mode" value="module.driver.transfer.src_addr_mode.addr_mode_incremented"/>
            <override property="module.driver.transfer.repeat_area" value="module.driver.transfer.repeat_area.repeat_area_source"/>
            <override property="module.driver.transfer.p_dest" value="NULL"/>
            <override property="module.driver.transfer.p_src" value="NULL"/>
            <override property="module.driver.transfer.length" value="0"/>
            <override property="module.driver.transfer.interrupt" value="module.driver.transfer.interrupt.interrupt_end"/>
            <override property="module.driver.transfer.num_blocks" value="0"/>
            <override property="module.driver.transfer.auto_enable" value="module.driver.transfer.auto_enable.false"/>
            <override property="module.driver.transfer.p_callback" value="NULL"/>
            <override property="module.driver.transfer.activation_source" value="module.driver.transfer.event.event_usbfs_fifo_0"/>
        </requires>
        <requires id="module.framework.sf_el_ux_dcd_fs.requires.transfer_rx" interface="interface.driver.transfer" display="Add Transfer Module for RX [Recommended but optional]">
            <override property="module.driver.transfer.size" value="module.driver.transfer.size.size_1_byte"/>
            <override property="module.driver.transfer.mode" value="module.driver.transfer.mode.mode_block"/>
            <override property="module.driver.transfer.dest_addr_mode" value="module.driver.transfer.dest_addr_mode.addr_mode_incremented"/>
            <override property="module.driver.transfer.src_addr_mode" value="module.driver.transfer.src_addr_mode.addr_mode_fixed"/>
            <override property="module.driver.transfer.repeat_area" value="module.driver.transfer.repeat_area.repeat_area_destination"/>
            <override property="module.driver.transfer.p_dest" value="NULL"/>
            <override property="module.driver.transfer.p_src" value="NULL"/>
            <override property="module.driver.transfer.length" value="0"/>
            <override property="module.driver.transfer.interrupt" value="module.driver.transfer.interrupt.interrupt_end"/>
            <override property="module.driver.transfer.num_blocks" value="0"/>
            <override property="module.driver.transfer.auto_enable" value="module.driver.transfer.auto_enable.false"/>
            <override property="module.driver.transfer.p_callback" value="NULL"/>
            <override property="module.driver.transfer.activation_source" value="module.driver.transfer.event.event_usbfs_fifo_1"/>
        </requires>
        <provides interface="interface.framework.sf_el_ux_dcd" />
        <provides interface="interface.framework.sf_el_ux_dcd.${module.framework.sf_el_ux_dcd_fs.name}" />
        <provides interface="interface.framework.sf_el_ux_dcd.R_USBFS_BASE" />
        <property default="g_sf_el_ux_dcd_fs_${_instance}" display="Name" id="module.framework.sf_el_ux_dcd_fs.name" description="Module name.">
            <constraint display="Name must be a valid C symbol">testSymbol("${module.framework.sf_el_ux_dcd_fs.name}")</constraint>
        </property>
        <property default="R_USBFS_BASE" display="USB Controller Selection" id="module.framework.sf_el_ux_dcd_fs.hw_address" description="Select the USB controller.">
            <option display="USBFS" id="module.framework.sf_el_ux_dcd_fs.hw_address.fs" value="R_USBFS_BASE" />
        </property>
        <header>
            #include "ux_api.h"
            #include "ux_dcd_synergy.h"
            #include "sf_el_ux_dcd_fs_cfg.h"
            void ${module.framework.sf_el_ux_dcd_fs.name}_err_callback(void * p_instance, void * p_data);
        </header>
        <declarations>
            #if defined(__ICCARM__)
            #define ${module.framework.sf_el_ux_dcd_fs.name}_err_callback_WEAK_ATTRIBUTE
            #pragma weak ${module.framework.sf_el_ux_dcd_fs.name}_err_callback  = ${module.framework.sf_el_ux_dcd_fs.name}_err_callback_internal
            #elif defined(__GNUC__)
            #define ${module.framework.sf_el_ux_dcd_fs.name}_err_callback_WEAK_ATTRIBUTE   __attribute__ ((weak, alias("${module.framework.sf_el_ux_dcd_fs.name}_err_callback_internal")))
            #endif
            void ${module.framework.sf_el_ux_dcd_fs.name}_err_callback(void * p_instance, void * p_data) ${module.framework.sf_el_ux_dcd_fs.name}_err_callback_WEAK_ATTRIBUTE;
            #if (SF_EL_UX_CFG_FS_IRQ_IPL != BSP_IRQ_DISABLED)
            /* USBFS ISR vector registering. */
            #if !defined(SSP_SUPPRESS_ISR_${module.framework.sf_el_ux_dcd_fs.name}) &amp;&amp; !defined(SSP_SUPPRESS_ISR_USB)
            SSP_VECTOR_DEFINE_UNIT(usbfs_int_isr, USB, FS, INT, 0);
            #endif
            #endif

            /* Prototype function for USBX DCD Initializer. */
            static void ux_dcd_initialize(void);

            #undef SYNERGY_NOT_DEFINED
            #define SYNERGY_NOT_DEFINED (1)
            /*******************************************************************************************************************//**
             * @brief      This is a weak example initialization error function.  It should be overridden by defining a user  function 
             *             with the prototype below.
             *             - void ${module.framework.sf_el_ux_dcd_fs.name}_err_callback(void * p_instance, void * p_data)
             *
             * @param[in]  p_instance arguments used to identify which instance caused the error and p_data Callback arguments used to identify what error caused the callback.
             **********************************************************************************************************************/
            void ${module.framework.sf_el_ux_dcd_fs.name}_err_callback_internal(void * p_instance, void * p_data);
            void ${module.framework.sf_el_ux_dcd_fs.name}_err_callback_internal(void * p_instance, void * p_data)
            {
              /** Suppress compiler warning for not using parameters. */
              SSP_PARAMETER_NOT_USED(p_instance);
              SSP_PARAMETER_NOT_USED(p_data);

              /** An error has occurred. Please check function arguments for more information. */
              BSP_CFG_HANDLE_UNRECOVERABLE_ERROR(0);
            }
            #if ((SYNERGY_NOT_DEFINED != ${module.framework.sf_el_ux_dcd_fs.requires.transfer_tx::module.driver.transfer.name}) &amp;&amp; (SYNERGY_NOT_DEFINED != ${module.framework.sf_el_ux_dcd_fs.requires.transfer_rx::module.driver.transfer.name}))
            /***********************************************************************************************************************
             * The definition of wrapper interface for USBX Synergy Port DCD Driver to get a transfer module instance.
             **********************************************************************************************************************/
            static UINT ${module.framework.sf_el_ux_dcd_fs.name}_initialize_transfer_support(ULONG dcd_io)
            {
                UX_DCD_SYNERGY_TRANSFER dcd_transfer;
                dcd_transfer.ux_synergy_transfer_tx = (transfer_instance_t *)&amp;${module.framework.sf_el_ux_dcd_fs.requires.transfer_tx::module.driver.transfer.name};
                dcd_transfer.ux_synergy_transfer_rx = (transfer_instance_t *)&amp;${module.framework.sf_el_ux_dcd_fs.requires.transfer_rx::module.driver.transfer.name};
                return (UINT)ux_dcd_synergy_initialize_transfer_support(dcd_io, (UX_DCD_SYNERGY_TRANSFER *)&amp;dcd_transfer);
            }  /* End of function ${module.framework.sf_el_ux_dcd_fs.name}_initialize_transfer_support() */
            #endif

            /***********************************************************************************************************************
             * Initializes USBX Device Controller Driver.
             **********************************************************************************************************************/
            void ux_dcd_initialize(void)
            {
                UINT status;
                /* Initializes the USB device controller, enabling DMA transfer if transfer module instances are given. */
                #if ((SYNERGY_NOT_DEFINED == ${module.framework.sf_el_ux_dcd_fs.requires.transfer_tx::module.driver.transfer.name}) || (SYNERGY_NOT_DEFINED == ${module.framework.sf_el_ux_dcd_fs.requires.transfer_rx::module.driver.transfer.name}))
                status = (UINT)ux_dcd_synergy_initialize(R_USBFS_BASE);
                #else
                status = ${module.framework.sf_el_ux_dcd_fs.name}_initialize_transfer_support(R_USBFS_BASE);
                #endif
                #undef SYNERGY_NOT_DEFINED
                if (UX_SUCCESS != status)
                {
                   ${module.framework.sf_el_ux_dcd_fs.name}_err_callback(NULL,&amp;status);
                }
             }  /* End of function ux_dcd_initialize() */
        </declarations>
    </module>
</synergyModuleDescription>
